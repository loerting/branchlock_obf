package net.branchlock.task.implementation.naming.drivers;

import net.branchlock.Branchlock;
import net.branchlock.structure.BClass;
import net.branchlock.structure.BResource;
import net.branchlock.task.driver.implementations.ResourceDriver;
import net.branchlock.task.driver.passthrough.IPassThrough;
import net.branchlock.task.implementation.naming.Renamer;

import java.io.IOException;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class ResourceUpdaterDriver implements ResourceDriver {
  private final Renamer renamer;
  private static final long MAX_SIZE = 128 * 1024;
  private static final List<String> SUPPORTED_EXTENSIONS = Arrays.asList("xml", "yml", "yaml", "properties", "prop", "mf");

  private final AtomicInteger counter = new AtomicInteger(0);
  private Map<String, String> originalNameToNewName;

  public ResourceUpdaterDriver(Renamer renamer) {
    this.renamer = renamer;
  }

  @Override
  public void preDrive() {
    Branchlock.LOGGER.info("Updating class names in resources.");
    Branchlock.LOGGER.info("Supported resource types: {}", SUPPORTED_EXTENSIONS);
    // also remove possible null bytes that may have been generated by renamer.
    originalNameToNewName = renamer.dataProvider.streamInputClasses().collect(Collectors.toMap(BClass::getOriginalName,
      bClass -> bClass.getName().replace("\0", "")));
  }

  @Override
  public void postDrive() {
    Branchlock.LOGGER.info("Updated {} resource entries.", counter.get());
  }

  @Override
  public boolean drive(Stream<BResource> stream) {
    stream.forEach(resource -> {

      String extension = resource.getExtension().toLowerCase();
      if (!SUPPORTED_EXTENSIONS.contains(extension)) return;

      byte[] content;
      try {
        content = resource.getContent(renamer.dataProvider, MAX_SIZE);
      } catch (IOException e) {
        throw new RuntimeException(e);
      }
      if (content == null) {
        Branchlock.LOGGER.warning("Resource too big (>128kB) or failed to load: {}", resource.getOriginalName());
        return;
      }

      String contentString = new String(content);
        contentString = switch (extension) {
            case "xml" -> updateXML(contentString);
            case "yml", "yaml", "mf", "properties", "prop" -> updateProperties(contentString);
            default -> contentString;
        };
      resource.replacement = contentString.getBytes();
    });
    return true;
  }

  private String updateProperties(String document) {
    // split on CRLF or LF and keep the line endings
    String[] lines = document.split("(?<=\r\n)|(?<=\n)");
    for (int i = 0; i < lines.length; i++) {
      String line = lines[i];
      if(line.startsWith("#") || line.startsWith("!")) continue;
      Pattern pattern = Pattern.compile("\\s*([a-zA-Z0-9]+)\\s*[=:](.*)");
      Matcher matcher = pattern.matcher(line);
      if (matcher.find()) {
        String oldClassName = matcher.group(2).trim();
        String newClassName = checkForNewName(oldClassName);
        if (!oldClassName.equals(newClassName)) {
          String newLine = line.replace(oldClassName, newClassName);
          lines[i] = newLine;
          counter.incrementAndGet();
        }
      }
    }
    return String.join("", lines);
  }

  private String updateXML(String document) {
    // split on CRLF or LF and keep the line endings
    String[] lines = document.split("(?<=\r\n)|(?<=\n)");
    for (int i = 0; i < lines.length; i++) {
      String line = lines[i];
      if(line.trim().startsWith("<!--")) continue;
      Pattern pattern = Pattern.compile("<([^>]+)>(.*?)</\\1>");
      Matcher matcher = pattern.matcher(line);
      if (matcher.find()) {
        String oldClassName = matcher.group(2).trim();
        String newClassName = checkForNewName(oldClassName);
        if (!oldClassName.equals(newClassName)) {
          String newLine = line.replace(oldClassName, newClassName);
          lines[i] = newLine;
          counter.incrementAndGet();
        }
      }
    }
    return String.join("", lines);
  }


  public String checkForNewName(String possibleClassName) {
    if (possibleClassName.length() <= 4) return possibleClassName;
    String newName = originalNameToNewName.get(possibleClassName.replace('.', '/'));
    if (newName == null) return possibleClassName;
    return possibleClassName.contains(".") ? newName.replace('/', '.') : newName;
  }


  @Override
  public Collection<IPassThrough<BResource>> passThroughs() {
    return renamer.defaultMemberExclusionHandlers();
  }

  @Override
  public String identifier() {
    return "resource-updater";
  }
}
